#-*- coding: utf-8 -*-import socketimport pickleimport datetimeimport threading#==================================================================================================="""ПОМЕНЯЛ ПОРЯДОК! ТЕПЕРЬ ДАТА И ВРЕМЯ В ОДНОМ ЭЛЕМЕНТЕ! ВРЕМЯ НОРМИРОВКИ И ВРЕМЯ УСТАНОВКИ ПОМЕНЯЛИСЬ МЕСТАМИОПЕРАТОР СТАЛ ВТОРЫМ!"""#Станок_________________________________________[0]#Номер заказа___________________________________[1]#Дата постановки на станок______________________[2]#Время постановки на станок_____________________[3]#Часы по нормеровке_____________________________[4]#Планируемое время: Дата окончания обработки____[5]#                   Время окончания обработки___[6]#Фактическое время: Дата окончания обработки____[7]#                   Время окончания обработки___[8]#Оператор_______________________________________[9]#Статус________________________________________[10]#Прична простоя оборудования___________________[11]#Простой начался:   Дата начала простоя________[12]#                   Время начала простоя_______[13]#Простой закончился: Дата конца простоя________[14]#                    Время конца простоя_______[15]#Общее время простоя___________________________[16]#Фактическое время обработки___________________[17]def arrCollect(command, array):    dataTime = datetime.datetime.now()    #Заполняем массив исходя из команды    if command == 'start':        ##########################################################        dataInst = datetime.date.strftime(dataTime,'%d-%m-%y %H:%M:%S')               #Текущая дата        array[4] = dataInst        print(dataInst)        ##########################################################        #РАЗОБРАТЬСЯ С ЭТИМ КУДА?        #Добавляем время начала в список для расчета времени всей работы        mytimearray.append(dataTime)        #print(mytimearray[0])        #########################################################        #ВОТ ЭТО НУЖНО ПРЕВРАТИТЬ В "ГГГГ-ММ-ДД ЧЧ-ММ-СС"        #Расчитываем плановую дату        pdate = dataTime + datetime.timedelta(hours=int(array[3]))        planDate = datetime.date.strftime(pdate, '%d-%m-%y %H:%M:%S')   #планируемая дата        array[5] = planDate        print(array[5])        #array[6] = '' # Фактическое время еще не известно, пустышка.        ###################################################        state = get_currentState(command)        array[7]=state        print(array[7])        return array    #Заполнение массива при постановке на паузу по какой либо причине(Причина указывается)    elif command == 'pause':        tempArr = array.copy()        for i in range(len(tempArr)):            tempArr[i] = ''        tempArr[0] = machine        tempArr[1] = array[1]        tempArr[9] = array[9]        tempArr[10] = get_currentState(command)        array[10] = tempArr[10]        tempArr[11] = input('Причина простоя: ')        tempArr[12] = datetime.date.strftime(dataTime,'%d.%m.%y')        array[12] = datetime.datetime.now()        tempArr[13] = datetime.date.strftime(datetime.datetime.now(),'%H:%M:%S')        return tempArr    elif command == 'continue':        #Копируем исходный массив        tempArr = array.copy()        #Заполняем прочерками        for i in range(len(tempArr)):             tempArr[i] = ''        tempArr[0] = machine        tempArr[1] = array[1]        tempArr[9] = array[9]#Сделать проверку на пересменок        tempArr[10] = get_currentState(command)        array[10] = tempArr[10]        tempArr[14] = datetime.date.strftime(dataTime, '%d.%m.%y')        tempArr[15] = datetime.date.strftime(datetime.datetime.now(), '%H:%M:%S')        #delta = datetime.timedelta(days= int(myarray[12].day), hours = myarray[12].hour, minutes=myarray[12].minute,        #                           seconds=myarray[12].second)        #print(delta)        delta = dataTime - array[12]        days = delta.days        hours = delta.seconds//3600        minutes = (delta.seconds%3600)//60        print( str(hours)+":"+str(minutes) )        p = int(delta.days) - int(dataTime.day)        #ДАТА - ДАТА , а потом берем из дельты количество минут!        tempArr[16] = '%02d:%02d' % (hours,minutes)        print (tempArr[16])        return tempArr    elif command == 'stop':        tempArr = array.copy()        for i in range(len(tempArr)):            tempArr[i] = ''        tempArr[0]= machine        tempArr[1]= array[1]        tempArr[7] = datetime.date.strftime(dataTime, '%d.%m.%y')        tempArr[8] = datetime.date.strftime(datetime.datetime.now(), '%H:%M:%S')        tempArr[9]= array[9]        tempArr[10]= get_currentState(command)        finishdelta = dataTime - mytimearray[0]        hours = finishdelta.seconds // 3600        minutes = (finishdelta.seconds % 3600) // 60        tempArr[17] =  '%02d:%02d' % (hours,minutes)        print(tempArr[17])        # Так как дата установки это стринг, сделать список с хранилищем времени в формате Date.        # в который при старте будет заносится объект, а при стопе использоваться для вычисления        # фактической даты окончания. Потом этот лист необходимо будет очищать вместе с основным.        del array[:]        del mytimearray[:]        return tempArr#===================================================================================================def sendingData(arr):    g = pickle.dumps(arr)    print('Client: Отправка запроса.')    reply1 = s.send(str.encode(command))    while reply1 is True:        reply1 = s.send(g)    print('Client: Запрос отправлен.')    reply = s.recv(1024)    if (reply.decode('utf-8')) == 'OK':        reply = s.send(g)        while reply is True:            reply = s.send(g)        print('Client: Список отправлен.')        reply = s.recv(1024)        print(reply.decode('utf-8'))def collect_and_send(cmd):    arr_to_send = arrCollect(cmd)    sendingData(arr_to_send)def get_currentUser():    cu = input('Оператор :')    return cudef get_currentOrder():    co = input('Номер заказа: ')    order = co    return codef get_currentState(cmd):    if cmd == 'start':        return 'В работе'    elif cmd == 'pause':        return 'Простой'    elif cmd == 'stop':        return 'Закончен'    elif cmd == 'continue':        return 'Работа возобновлена'    else:        return 'whats wrong?'def get_currentNorm():    cn = input('Нормировка в часах: ')    return cndef transfer_command(command,s):    rawcommand = pickle.dumps(command)    s.send(rawcommand)def transfer_list(s,command):    pList = pickle.dumps(arrCollect(command))    #NAME_OF_MACHINE.send(pList)    reply = s.send(pList)    while reply is True:        reply = s.send(pList)def transfer_from_server():    messg = s.recv(1024)    mess = pickle.loads(messg)    return messdef set_command(cmd):    global c    c = cmddef get_command():    if c == None:        com = "wait"    return comdef client_processes(s):    global aaa    while True:        if(aaa=='wait'):            #print("wait..")            pass        else:            if aaa == 'exit':                #send EXIT request to other end                transfer_command(aaa)                break            elif aaa == 'kill':                transfer_command(aaa)                break            elif aaa == 'start':                if array != []:                    print('Работа в процессе!')                    aaa = 'wait'                else:                    #command_from_='wait'                    #collect_and_send(aaa)                    transfer_command(aaa,s)                    transfer_list(s,aaa)                    aaa = 'wait'            elif aaa == 'pause':                if array == []:                    print('Нет активной работы!')                elif array != [] and array[10]== 'Простой'  :                    print('Есть актвный простой!')                else:                    transfer_command(aaa)                    transfer_list()            elif aaa == 'continue':                if array == [] or array[10]== 'В работе':                    print('Нет активного простоя!')                elif array != [] and array[10]== 'Работа возобновлена':                    print('Работа уже возобновлена!')                else:                    transfer_command(aaa)                    transfer_list()        #Написать условие для стопа во время паузы, стопа без работы            elif aaa == 'stop':                if array == []:                    "Нет активной работы"                elif array[10] == "Простой":                    print("Завершите активный простой!")                else:                    transfer_command(aaa)                    transfer_list()            else:                transfer_command(aaa,s)                #reply = transfer_from_server()            #reply = transfer_from_server()            #print(reply)    print('Отключаюсь от : ' + str(s.getpeername()))    s.close()# #Объявляем переменные для сокета# host = '127.0.0.1'# port = 5560#Объявляем переменную с названием станкаmachine ='ДИП-500'command_from_ui ="wait"#Объявляем переменные списков#array=[] #Главный списокmytimearray=[]#Список для расчёта общего времени# #Создаем сокет# NAME_OF_MACHINE = socket.socke# t(socket.AF_INET, socket.SOCK_STREAM)# NAME_OF_MACHINE.connect((host, port))# print('Подключен к : ' + str(NAME_OF_MACHINE.getpeername()))#Основной цикл для приёма команды